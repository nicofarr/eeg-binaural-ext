from mne.io import read_raw_edf,RawArray,read_raw_fif
from mne.export import export_raw
from mne import find_events,annotations_from_events,write_events,create_info,read_events, Epochs
from mne.preprocessing import find_eog_events
import matplotlib.pyplot as plt 
import pandas as pd
import numpy as np
from scipy.signal import find_peaks
from mne import Epochs
import mne 
import argparse
from saveevents import addevents
from mne.viz import plot_events


parser = argparse.ArgumentParser(description='Add events')

parser.add_argument('-i', type=str,help='Path to openbci edf file generated by import_reref.py')
parser.add_argument('--control', type=str,required=True,help='Path to recordcontrol file')
parser.add_argument('--decal', type=int,default=0,help='Events to remove in the begining')
    
args = parser.parse_args()
edffile = args.i
controlfile = args.control

eventsfile = edffile[:-4] + '_eve.fif'

raw = read_raw_fif(edffile,preload=True)
events = read_events(eventsfile)



def remove_bad_trigger(events,raw):
    annotations = raw.annotations
    onsets = events[:,0]
    for ann in annotations:
        descr = ann['description']
        start = ann['onset']
        end = ann['onset'] + ann['duration']
        if descr=='bad_trigger':
            
            ## find it in the events list and change its type 
            for i,onset in enumerate(onsets):
                if (onset > raw.time_as_index(start)) and (onset <= raw.time_as_index(end)):
                    events[i,2]=99
                    break
    
    return events
        


events_ann = remove_bad_trigger(events,raw)


from saveevents import addevents

#  Read order of events from the recordcontrol file 
events_ctrl,_,merged_events_dict = addevents(controlfile)

# Replace the identity of events (last column)
decal=args.decal
events_ann[events_ann[:,2]==1,2] =  events_ctrl[decal:,2]

## Keep only the events corresponding to good triggers 
events_final = events_ann[events_ann[:,2]!=99,:]

### Remove first sound of each sequence of 10 because there are head movements 
first_sounds = np.arange(0,events_final.shape[0],10)

second_sounds = np.arange(0,events_final.shape[0],10)+1
third_sounds = np.arange(0,events_final.shape[0],10)+2


events_final[first_sounds,:]=[1,1,98]

## Also remove the second sound 
events_final[second_sounds,:]=[1,1,98]
## Also remove the third sound 

events_final[third_sounds,:]=[1,1,98]

events_final = events_final[events_final[:,2]!=98,:]

# Preprocessing of the raw data
# --

# - Notch filter has already been done 
# - Bad segments have been annotated

# Blink detection

from mne.preprocessing import (ICA, create_eog_epochs, create_ecg_epochs,
                               corrmap)

raw.set_channel_types({'EOG':'eog'})



raw.set_channel_types({'TRIG':'stim'})

raw.set_montage('standard_1020')


eog_ev = find_eog_events(raw=raw,ch_name='EOG')


# Filtering for drift on copy 

filt_raw = raw.copy().filter(l_freq=1., h_freq=40)


## Add the blink events to the events structure 

events_final = np.vstack([events_final,eog_ev])


## Add the blinks to the dictionnary 
merged_events_dict['blink']=998


## Epoch the data for ICA 

epochs_forica = Epochs(filt_raw, events_final, event_id=merged_events_dict,tmin=-0.2, tmax=0.5,baseline=None,reject_by_annotation=True,
                    preload=True)

ica = ICA(method='fastica', max_iter="auto").fit(epochs_forica)

ica.plot_components()

#ica.plot_properties(epochs_forica)

##### Select which components to remove 

ica.exclude = eval(input('List of ICA Components to exclude (example : [1,2,3] will exclude comp001,comp002 and comp003, [] will not exclude any ): '))# indices chosen based on various plots above

#ica.exclude = [0,2,3]
### Apply ICA on the raw (unfiltered, no baseline correction) Data 
ica.apply(raw)

### Finally filter the data 

raw = raw.filter(l_freq=0.1, h_freq=40)

raw.plot(block=True,events=events_final,event_id=merged_events_dict,scalings ={'eeg':'auto','misc':1e4})


### Epoch the corrected data 

epochs = Epochs(raw, events_final, event_id=merged_events_dict,tmin=-0.2, tmax=0.5,baseline=(-0.2,0),reject_by_annotation=True,detrend=1,
                    preload=True)

conditions = ['NM, NHT','MHT','M, NHT']
evoked_dict = dict()
for cond in conditions:
    evoked_dict[cond] = epochs[cond].average()

#mne.viz.plot_compare_evokeds(evoked_dict, picks=['C3','C4','Cz'],combine='mean')



evokeds_cfdt = dict(SF=list(epochs['NM, NHT'].iter_evoked()),
               DM=list(epochs['MHT'].iter_evoked()),
               SM= list(epochs['M, NHT'].iter_evoked()))

mne.viz.plot_compare_evokeds(evokeds_cfdt, combine='mean', picks=['C3','C4','Cz'])



""" 
epochs = Epochs(raw, events_final, event_id=merged_events_dict,tmin=-0.2, tmax=0.5,baseline=(-0.2,0),reject_by_annotation=True,
                    preload=True)

conditions = merged_events_dict.keys()
evoked_dict = dict()
for cond in conditions:
    evoked_dict[cond] = epochs[cond].average()


 """
## Plot evoked response 

